import { isEmpty, compact, shuffle, isEqual, random } from "lodash";

export const VALID_NUMBERS = [1,2,3,4,5,6,7,8,9]

export interface Cell {
  autogenerated: boolean;
  value?: number;
  solution?: number;
  coordinate: Coordinate;
}

export interface Coordinate {
  x: number;
  y: number;
}

export const generateCell = (
  coordinate: Coordinate,
  solution: number = 0
): Cell => ({
  autogenerated: false,
  coordinate,
  solution
});

export const generateCoordinate = (x: number, y: number): Coordinate => ({
  x,
  y
});

export const generateBoard = (): Cell[][] => {
  let board: Cell[][] = [];
  let backtrackingCount = 0;
  rowLoop: for (let x = 0; x < 9; x++) {
    board.push([]);
    const foundValues = [];
    for (let y = 0; y < 9; y++) {
      const coordinate = generateCoordinate(x, y);
      const value = findValue(board, coordinate, foundValues);
      if (!value) {
        /*
          sometimes the random sudoku generation gets stuck in an imposible solution:
          this happens when multiple rows start and end with the same number eg

          7,6,9,8,3,4,5,1,2
          2,5,1,9,7,6,3,4,8
          8,3,4,1,2,5,9,7,6
          6,1,5,4,8,2,7,9,3
          9,2,8,3,6,7,4,5,1
          3,

          here the 2,8,6 and 3 are both in column 1 and column 9. On these occasions
          after a large number of backtracking attempts, it is best to clear the 
          whole sudoku and start afresh
        */
        if (backtrackingCount > 40) {
          x = -1; // reset to 0 once we continue
          backtrackingCount = 0;
          board = []; // clear board
          continue rowLoop;
        }

        /*
          if no value is found then the row is wrong and it needs to be backtracked
        */
        board.splice(x, 1); // delete row exisiting values
        x--;
        backtrackingCount++;
        continue rowLoop;
      }
      board[x][y] = generateCell(coordinate, value);
      foundValues.push(value);
    }
  }
  return board;
};

const findValue = (
  board: Cell[][],
  coordinate: Coordinate,
  foundValues: number[]
): number => {
  const possibleValues = shuffle(VALID_NUMBERS); // randomise solution
  for (let i = 0; i < 9; i++) {
    if (foundValues.includes(possibleValues[i])) {
      continue;
    }
    if (canSetValueInBoard(possibleValues[i], coordinate, board)) {
      return possibleValues[i];
    }
  }
};

export const printBoard = (board: Cell[][]): string =>
  board.reduce(
    (acc, cur) => (acc += `${cur.map(y => y.solution).join(",")}\n`),
    ""
  );

export const printGame = (board: Cell[][]): string =>
  board.reduce(
    (acc, cur) => (acc += `${cur.map(y => y.autogenerated? y.solution : " ").join(",")}\n`),
    ""
  );

export const doesValueExistInRow = (
  board: Cell[][],
  value: number,
  rowId: number
): Coordinate | undefined => {
  for (let i = 0; i < 9; i++) {
    const rowValue = board[rowId][i];
    if (!isEmpty(rowValue) && rowValue.solution === value) {
      return rowValue.coordinate;
    }
  }
};

export const doesValueExistInColumn = (
  board: Cell[][],
  value: number,
  columnId: number
): Coordinate | undefined => {
  for (let i = 0; i < 9; i++) {
    const columnValue = board[i] && board[i][columnId];
    if (!isEmpty(columnValue) && columnValue.solution === value) {
      return columnValue.coordinate;
    }
  }
};

/*
  The Sudoku board is split in 9 squares of 3 x 3 cells. It is illegal to
  attempt to add a number in a square if that number already exists in
  such square

  we create a mapping (squareAreaMapping) to determine what square we are trying
  to add a number to, a square is composed of x and y coordinates i.e [0,1,2]
  and [3,4,5]

  by taking the x and y coordinates of the cell we attemp to enter a number to
  and dividing them by 3 (getSquareAreaMapping) we are able to extract the current
  square neighbouring cells
*/

const squareAreaMapping = [
  [0, 1, 2],
  [3, 4, 5],
  [6, 7, 8]
];

const getSquareAreaMapping = (coordinate: number): number[] =>
  squareAreaMapping[Math.floor(coordinate / 3)];

export const doesValueExistInSquare = (
  board: Cell[][],
  value: number,
  coordinate: Coordinate
): Coordinate => {
  const x = getSquareAreaMapping(coordinate.x);
  const y = getSquareAreaMapping(coordinate.y);
  for (let i = 0; i < x.length; i++) {
    for (let b = 0; b < y.length; b++) {
      const cell = board[x[i]] && board[x[i]][y[b]];
      if (cell && cell.solution === value) {
        return cell.coordinate;
      }
    }
  }
};

export const canSetValueInBoard = (
  value: number,
  coordinate: Coordinate,
  board: Cell[][]
): boolean =>
  isEmpty(doesValueExistInRow(board, value, coordinate.x)) &&
  isEmpty(doesValueExistInColumn(board, value, coordinate.y)) &&
  isEmpty(doesValueExistInSquare(board, value, coordinate));

export const getRowValues = (
  board: Cell[][],
  rowId: number
): number[] => board[rowId].map(cell => cell.solution)

export const getColumnValues = (board: Cell[][], columnId: number): number[] =>
  compact(
    [0, 1, 2, 3, 4, 5, 6, 7, 8].map(i => {
      const value = board[i] && board[i][columnId];
      return isEmpty(value) ? undefined : value.solution;
    })
  );

export const getSquareValues = (
  board: Cell[][],
  coordinate: Coordinate): number[] => {
    const x = getSquareAreaMapping(coordinate.x);
    const y = getSquareAreaMapping(coordinate.y);
    const values = []
    x.forEach(xCoord => {
      y.forEach(yCoord => {
          const cell = board[xCoord] && board[xCoord][yCoord];
          values.push(cell.solution);
      })
    });
    return compact(values)
  }

export const isSudokuValid = (board: Cell[][]): boolean => {
  for (let x = 0; x < board.length; x++) {
    if (!isEqual(getRowValues(board,x).sort(),VALID_NUMBERS)) {
      return false
    }
  }

  for (let x = 0; x < VALID_NUMBERS.length; x++) {
    if (!isEqual(getColumnValues(board,x).sort(),VALID_NUMBERS)) {
      return false
    }
  }
  const coordinates = [
    {x:0, y: 0},
    {x:0, y: 3},
    {x:0, y: 6},
    {x:3, y: 0},
    {x:3, y: 3},
    {x:3, y: 6},
    {x:6, y: 0},
    {x:6, y: 3},
    {x:6, y: 6},
  ]

  for (let x = 0; x < coordinates.length; x++) {
    if (!isEqual(getSquareValues(board,coordinates[x]).sort(),VALID_NUMBERS)) {
      return false
    }
  }
  return true
}

export const difficulty = {
  'EASY': [6,3,3,3,3,3,2,4,6],
  'MEDIUM': [2,3,4,3,6,1,4,3],
  'HARD': [4,3,2,2,3,3,5,1,4],
  'EXPERT': [2,1,2,3,4,6,3,4,2]
}

export interface Difficulty {
  [key: number]: {count: number}
}

/*
  Creates a map with the number of instances of every number visible in the board
*/
export const createNumberDifficultyMap = (difficulty: number[], numbers: number[]): Difficulty => {
  return difficulty.reduce(
    (acc: Difficulty, cur: number, index) => {
      const num = cur
      acc[numbers[index]] = { count: random(num - 1, num) }
      return acc
    },
    {}
  );
}

export const createGameCoordinates = (): Coordinate[] => {
  const coordinates = [];
    [0, 1, 2, 3, 4, 5, 6, 7, 8].forEach(x => {
      [0, 1, 2, 3, 4, 5, 6, 7, 8].forEach(y => {
        coordinates.push({x, y})
      });
    });
    return coordinates
}

export const createGame = (board: Cell[][], difficulty: Difficulty): Cell[][] => {
  shuffle(createGameCoordinates()).forEach(coordinate => {
      const cell = board[coordinate.x][coordinate.y]
      if (difficulty[cell.solution].count) {
        cell.autogenerated = true
        difficulty[cell.solution].count--
      }
  });
  return board
}
