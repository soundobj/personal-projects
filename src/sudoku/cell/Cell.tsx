import React, { useRef } from "react";
import { random } from "lodash";
// @ts-ignore
import classnames from "classnames";
import equal from "fast-deep-equal";
import {
  Cell as CellProps,
  Coordinate,
  MoveTypes,
  Transitions,
} from "../lib/definitions";
import Candidates from "./candidates/Candidates";
import RandomNumber from "../randomNumber/RandomNumber";
import "./Cell.scss";

export const useCountRenders = (coordinate: Coordinate) => {
  const renders = useRef(0);
  console.error(
    `@renders x:${coordinate.x}y:${coordinate.y}`,
    renders.current++
  );
};

interface Props extends CellProps {
  selectCell: (coordinate: Coordinate) => void;
  transition?: Transitions;
}

export const cellAnimations: Record<Transitions, string[]> = {
  ["GAME_OVER"]: [
    "cell__game-over__rotate-forwards",
    "cell__game-over__fall-from-bottom",
    "cell__game-over__rotate-out",
  ],
  ["GAME_COMPLETED"]: [],
  ["NEW_GAME"]: [],
};

const Cell = (props: Props): JSX.Element => {
  const {
    value,
    autogenerated,
    coordinate,
    solution,
    selectCell,
    selected,
    candidates,
    conflicting,
    related,
    sameAsSelected,
    transition,
  } = props;
  // useCountRenders(coordinate)
  let transitionClass = "";
  if (transition) {
    const transitionClasses = cellAnimations[transition];
    transitionClass =
      transitionClasses[random(0, transitionClasses.length - 1)];
  }
  return (
    <div
      className="grid__item"
      onClick={() => selectCell(coordinate)}
      key={value}
    >
      <div
        className={classnames("content", {
          "sudoku__cell--related": related,
          "sudoku__cell--selected": selected,
        })}
      >
        <div
          key={`conflicting-cell-${Date.now()}`}
          className={classnames("content-inside", {
            "sudoku__cell--conflicting": conflicting,
            "sudoku__cell--same-as-selected":
              sameAsSelected && sameAsSelected.type === MoveTypes.NUMBER,
          })}
        >
          {autogenerated && !transition && (
            <h2 className={transitionClass}>{solution}</h2>
          )}
          {autogenerated && transition === "NEW_GAME" && (
            <RandomNumber interval={100} />
          )}
          {!autogenerated && value && (
            <h2
              className={classnames(transitionClass, {
                incorrect: value !== solution,
              })}
            >
              {value}
            </h2>
          )}
          {!autogenerated && !value && candidates && (
            <Candidates
              candidates={candidates}
              selected={selected}
              sameAsSelected={sameAsSelected}
            />
          )}
        </div>
      </div>
    </div>
  );
};

export const shouldCellRender = (
  prevProps: Props,
  nextProps: Props
): boolean => {
  let eq = equal(prevProps, nextProps);
  const isConflictingCell =
    prevProps.conflicting === true &&
    prevProps.conflicting === nextProps.conflicting;
  return eq && isConflictingCell ? false : eq;
};

export default React.memo(Cell, shouldCellRender);
