import {
  isEmpty,
  compact,
  shuffle,
  isEqual,
  random,
  concat,
  uniqBy,
  last,
  curry,
} from "lodash";

import { Cell, Coordinate, Coordinable, NumberDifficulty, GameLevel, Direction, VALID_NUMBERS } from './definitions'

export const generateCell = (
  coordinate: Coordinate,
  solution: number = 0,
  autogenerated: boolean = false
): Cell => ({
  autogenerated,
  coordinate,
  solution
});

export const generateBoard = (): Cell[][] => {
  let board: Cell[][] = [];
  let backtrackingCount = 0;
  rowLoop: for (let x = 0; x < 9; x++) {
    board.push([]);
    const foundValues = [];
    for (let y = 0; y < 9; y++) {
      const coordinate = { x, y };
      const value = findValue(board, coordinate, foundValues);
      if (!value) {
        /*
          sometimes the random sudoku generation gets stuck in an imposible solution:
          this happens when multiple rows start and end with the same number eg

          7,6,9,8,3,4,5,1,2
          2,5,1,9,7,6,3,4,8
          8,3,4,1,2,5,9,7,6
          6,1,5,4,8,2,7,9,3
          9,2,8,3,6,7,4,5,1
          3,

          here the 2,8,6 and 3 are both in column 1 and column 9. On these occasions
          after a large number of backtracking attempts, it is best to clear the 
          whole sudoku and start afresh
        */
        if (backtrackingCount > 40) {
          x = -1; // reset to 0 once we continue
          backtrackingCount = 0;
          board = []; // clear board
          continue rowLoop;
        }

        /*
          if no value is found then the row is wrong and it needs to be backtracked
        */
        board.splice(x, 1); // delete row exisiting values
        x--;
        backtrackingCount++;
        continue rowLoop;
      }
      board[x][y] = generateCell(coordinate, value);
      foundValues.push(value);
    }
  }
  return board;
};

const findValue = (
  board: Cell[][],
  coordinate: Coordinate,
  foundValues: number[]
): number | undefined => {
  const possibleValues = shuffle(VALID_NUMBERS); // randomise solution
  for (let i = 0; i < 9; i++) {
    if (foundValues.includes(possibleValues[i])) {
      continue;
    }
    if (canSetValueInBoard(possibleValues[i], coordinate, board)) {
      return possibleValues[i];
    }
  }
};

export const printBoard = (board: Cell[][]): string =>
  board.reduce(
    (acc, cur) => (acc += `${cur.map(y => y.solution).join(",")}\n`),
    ""
  );

export const printGame = (board: Cell[][]): string =>
  board.reduce(
    (acc, cur) => (acc += `${cur.map(y => y.autogenerated? y.solution : " ").join(",")}\n`),
    ""
  );

export const doesValueExistInRow = (
  board: Cell[][],
  value: number,
  rowId: number
): Coordinate | undefined => {
  for (let i = 0; i < 9; i++) {
    const rowValue = board[rowId][i];
    if (!isEmpty(rowValue) && rowValue.solution === value) {
      return rowValue.coordinate;
    }
  }
};

export const doesValueExistInColumn = (
  board: Cell[][],
  value: number,
  columnId: number
): Coordinate | undefined => {
  for (let i = 0; i < 9; i++) {
    const columnValue = board[i] && board[i][columnId];
    if (!isEmpty(columnValue) && columnValue.solution === value) {
      return columnValue.coordinate;
    }
  }
};

/*
  The Sudoku board is split in 9 squares of 3 x 3 cells. It is illegal to
  attempt to add a number in a square if that number already exists in
  such square

  we create a mapping (squareAreaMapping) to determine what square we are trying
  to add a number to, a square is composed of x and y coordinates i.e [0,1,2]
  and [3,4,5]

  by taking the x and y coordinates of the cell we attemp to enter a number to
  and dividing them by 3 (getSquareAreaMapping) we are able to extract the current
  square neighbouring cells
*/

const squareAreaMapping = [
  [0, 1, 2],
  [3, 4, 5],
  [6, 7, 8]
];

const getSquareAreaMapping = (coordinate: number): number[] =>
  squareAreaMapping[Math.floor(coordinate / 3)];

export const doesValueExistInSquare = (
  board: Cell[][],
  value: number,
  coordinate: Coordinate
): Coordinate | undefined => {
  const x = getSquareAreaMapping(coordinate.x);
  const y = getSquareAreaMapping(coordinate.y);
  for (let i = 0; i < x.length; i++) {
    for (let b = 0; b < y.length; b++) {
      const cell = board[x[i]] && board[x[i]][y[b]];
      if (cell && cell.solution === value) {
        return cell.coordinate;
      }
    }
  }
};

export const canSetValueInBoard = (
  value: number,
  coordinate: Coordinate,
  board: Cell[][]
): boolean =>
  isEmpty(doesValueExistInRow(board, value, coordinate.x)) &&
  isEmpty(doesValueExistInColumn(board, value, coordinate.y)) &&
  isEmpty(doesValueExistInSquare(board, value, coordinate));

export const getRow = <T extends Coordinable>(
  board: T[][],
  rowId: number
): T[] => board[rowId]

export const getColumn = <T extends Coordinable>(board: T[][], coordinate: Coordinate | number): T[] => {
  const y = (typeof coordinate === "number") ? coordinate : coordinate.y
  return compact(
    [0, 1, 2, 3, 4, 5, 6, 7, 8].map(x => {
      return board[x] && board[x][y];
    })
  );
}
 
export const getSquare = <T extends Coordinable>(
  board: T[][],
  coordinate: Coordinate
): T[] => {
  const x = getSquareAreaMapping(coordinate.x);
  const y = getSquareAreaMapping(coordinate.y);
  const values: T[] = [];
  x.forEach(xCoord => {
    y.forEach(yCoord => {
      const cell = board[xCoord] && board[xCoord][yCoord];
      values.push(cell);
    });
  });
  return compact(values);
};
  
export const getRowValues = (
  board: Cell[][],
  rowId: number
) => getRow(board, rowId).map(cell => cell.solution)

export const getColumnValues = (board: Cell[][], coordinate: Coordinate | number) =>
  getColumn(board, coordinate).map(cell => isEmpty(cell) ? undefined : cell.solution)

export const getSquareValues = (
  board: Cell[][],
  coordinate: Coordinate) =>
  getSquare(board, coordinate).map(cell => cell.solution) 

// every cell in the sudoku board belongs to a row, square and a column. get those related cells
export const getRelatedCells = (
  board: Coordinable[][],
  coordinate: Coordinate
): Coordinable[] =>
  uniqBy(
    concat(
      getRow(board, coordinate.x),
      getColumn(board, coordinate.y),
      getSquare(board, coordinate)
    ),
    (cell: Coordinable) => [cell.coordinate.x, cell.coordinate.y].join()
  );


export const isSudokuValid = (board: Cell[][]): boolean => {
  for (let x = 0; x < board.length; x++) {
    if (!isEqual(getRowValues(board,x).sort(),VALID_NUMBERS)) {
      return false
    }
  }

  for (let x = 0; x < VALID_NUMBERS.length; x++) {
    if (!isEqual(getColumnValues(board,x).sort(),VALID_NUMBERS)) {
      return false
    }
  }
  const coordinates = [
    {x:0, y: 0},
    {x:0, y: 3},
    {x:0, y: 6},
    {x:3, y: 0},
    {x:3, y: 3},
    {x:3, y: 6},
    {x:6, y: 0},
    {x:6, y: 3},
    {x:6, y: 6},
  ]

  for (let x = 0; x < coordinates.length; x++) {
    if (!isEqual(getSquareValues(board,coordinates[x]).sort(),VALID_NUMBERS)) {
      return false
    }
  }
  return true
}

export const countAutoGeneratedCells = (difficulty: NumberDifficulty): number => {
  return Object.values(difficulty).reduce((t, {count}) => t + count, 0)
}

export const difficulty = {
  [GameLevel.EASY]:   [2, 3, 3, 3, 3, 3, 4, 6, 6],
  [GameLevel.MEDIUM]: [1, 2, 3, 3, 3, 4, 4, 5, 6],
  [GameLevel.HARD]:   [1, 2, 2, 3, 3, 3, 4, 5, 5],
  [GameLevel.EXPERT]: [1, 2, 2, 2, 3, 3, 4, 4, 5]
}

/*
  Creates a map with the number of instances of every number visible in the board
*/
export const createNumberDifficultyMap = (difficulty: number[], numbers: number[]): NumberDifficulty => {
  return difficulty.reduce(
    (acc: NumberDifficulty, cur: number, index) => {
      const num = cur
      acc[numbers[index]] = { count: random(num - 1, num) }
      return acc
    },
    {}
  );
}

export const createGameCoordinates = (): Coordinate[] => {
  const coordinates: Coordinate[] = [];
    [0, 1, 2, 3, 4, 5, 6, 7, 8].forEach(x => {
      [0, 1, 2, 3, 4, 5, 6, 7, 8].forEach(y => {
        coordinates.push({x, y})
      });
    });
    return coordinates
}

export const createGame = (board: Cell[][], difficulty: NumberDifficulty): Cell[][] => {
  shuffle(createGameCoordinates()).forEach(coordinate => {
      const cell = board[coordinate.x][coordinate.y]
      if (difficulty[cell.solution].count) {
        cell.autogenerated = true
        difficulty[cell.solution].count--
      }
  });
  return board
}

export const navigateBoard = (
  board: Coordinable[][],
  currentPosition: Coordinate,
  direction: string
): Coordinate => {
  const { x, y } = currentPosition;
  if (isEmpty(board[x][y])) {
    return { x: 0, y: 0 };
  }
  switch (direction) {
    case Direction.LEFT: {
      return !isEmpty(board[x][y - 1]) ?  board[x][y - 1].coordinate : currentPosition; 
    }
    case Direction.RIGHT: {
      return !isEmpty(board[x][y + 1]) ?  board[x][y + 1].coordinate : currentPosition; 
    }
    case Direction.UP: {
      return !isEmpty(board[x - 1]) && !isEmpty(board[x - 1][y])
        ? board[x - 1][y].coordinate
        : currentPosition;
    }
    case Direction.DOWN: {
      return !isEmpty(board[x + 1]) && !isEmpty(board[x + 1][y])
        ? board[x + 1][y].coordinate
        : currentPosition;
    }
    default:
      return currentPosition;
  }
};

export const nextLeftAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate
): Coordinate => {
  const { x: currentX, y: currentY } = currentPosition;
  const row = board[currentX];

  for (let index = currentY - 1; index > -1; index--) {
    const element = row[index];
    if (element.autogenerated || element.solution === element.value) {
      continue;
    }
    return element.coordinate;
  }
  return currentPosition;
};

export const nextRightAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate
): Coordinate => {
  const { x: currentX, y: currentY } = currentPosition;
  const row = board[currentX];

  for (let index = currentY + 1; index < row.length; index++) {
    const element = row[index];
    if (element.autogenerated || element.solution === element.value) {
      continue;
    }
    return element.coordinate;
  }
  return currentPosition;
};

export const nextDownAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate
): Coordinate => {
  const { x: currentX, y: currentY } = currentPosition;
  const column = getColumn(board, currentY);

  for (let index = currentX + 1; index < column.length; index++) {
    const element = column[index];
    if (element.autogenerated || element.solution === element.value) {
      continue;
    }
    return element.coordinate;
  }
  return currentPosition;
};

export const nextUpAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate
): Coordinate => {
  const { x: currentX, y: currentY } = currentPosition;
  const column = getColumn(board, currentY);

  for (let index = currentX - 1; index > -1; index--) {
    const element = column[index];
    if (element.autogenerated || element.solution === element.value) {
      continue;
    }
    return element.coordinate;
  }
  return currentPosition;
};

export const navigateBoardNextAvailable = (
  board: Cell[][],
  currentPosition: Coordinate,
  direction: string,
): Coordinate => {
  const { x, y } = currentPosition;
  if (isEmpty(board[x][y])) {
    return { x: 0, y: 0 };
  }
  switch (direction) {
    case Direction.LEFT: {
      return nextLeftAvailable(board, currentPosition)
    }
    case Direction.RIGHT: {
      return nextRightAvailable(board, currentPosition)
    }
    case Direction.UP: {
      return nextUpAvailable(board, currentPosition)
    }
    case Direction.DOWN: {
      return nextDownAvailable(board, currentPosition)
    }
    default:
      return currentPosition;
  }
};

// cell is available when is has not been autogenerated or correctly filled
const cellIsAvailable = (cell: Cell) => !(cell.autogenerated || cell.value && cell.solution === cell.value)

const findHigherCell =  (coordinate: Coordinate) => (item: Coordinable) => item.coordinate.y < coordinate.y

export const filterOutByCoordinateNotEqual = (coordinate: Coordinate) => (
  item: Coordinable
) =>
  [item.coordinate.x, item.coordinate.y].join() !==
  [coordinate.x, coordinate.y].join();


const chooseNextBoardCoordinate = (
  coordinate: Coordinate,
  direction: Direction
): Coordinate => {
  const { x, y } = coordinate;
  switch (direction) {
    // loop back to the last column if we reach the first column
    case Direction.UP: {
      return y === 0 ? { x: 8, y: 8 } : { x: 8, y: y - 1 };
    }
    // loop back to the first column if we reach the last column
    case Direction.DOWN: {
      return y === 8 ? { x: 0, y: 0 } : { x: 0, y: y + 1 };
    }
    // loop back to the last row if we reach the first row
    case Direction.LEFT: {
      return x === 0 ? { x: 8, y: 8 } : { x: x - 1, y: 8 };
    }
    // loop back to the first row if we reach the last row
    case Direction.RIGHT: {
      return x === 8 ? { x: 0, y: 0 } : { x: x + 1, y: 0 };
    }
    default:
      return coordinate;
  }
};

export const nextOverflowAvailable = (
  board: Cell[][],
  currentPosition: Coordinate,
  direction: Direction,
): Coordinate => {
  console.error("@position is ", currentPosition);
  // look in the same row or column and see if there is something scanning from the opposite side
  switch (direction) {
    case Direction.UP:
      {
        //getArea(board: Cell[][], currentPosition: Coordinate, direction: Direction): Cell[]
        const column = getColumn(board, currentPosition);
        const filterOutByCoordinateWithCurrentPosition = curry(filterOutByCoordinateNotEqual)(currentPosition)
        const availableCells = column.filter(cellIsAvailable).filter(filterOutByCoordinateWithCurrentPosition);
        // console.error("@available cells", availableCells);
        // try to move upwards in the column
        if (availableCells.length) {
          // getAreaScanHelper(direction: Direction): (coordinate: Coordinate) => Cell
          const findHigherCellWithCurrentPosition = curry(findHigherCell)(currentPosition)
          // const nextAvailableCell
          const higherCell = availableCells.find(
            findHigherCellWithCurrentPosition
          );
          if (higherCell) {
            return higherCell.coordinate;
          }
          // try to get lowest possible cell in the column next if any available
          // getOppositeNextAvailableCellHelper(direction: Direction): (Cell[]) => Cell
          const lastItem = last(availableCells)
          if (lastItem) {
            return lastItem.coordinate
          }
        }
        // recurse
        // console.error('@recursing', chooseNextBoardCoordinate(currentPosition, direction))
        return nextOverflowAvailable(board, chooseNextBoardCoordinate(currentPosition, direction), direction)
      }
    default: {
      console.error('@nextOverflowAvailable doing default', )
      return currentPosition
    }
  }
};
