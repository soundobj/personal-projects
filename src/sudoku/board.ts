import {
  isEmpty,
  last,
  curry,
} from "lodash";

import { Cell, Coordinate, Coordinable, NumberDifficulty, GameLevel, Direction, VALID_NUMBERS } from './definitions'
import { getRow, getColumn } from './utils'

export const navigateBoard = (
  board: Coordinable[][],
  currentPosition: Coordinate,
  direction: string
): Coordinate => {
  const { x, y } = currentPosition;
  if (isEmpty(board[x][y])) {
    return { x: 0, y: 0 };
  }
  switch (direction) {
    case Direction.LEFT: {
      return !isEmpty(board[x][y - 1]) ?  board[x][y - 1].coordinate : currentPosition; 
    }
    case Direction.RIGHT: {
      return !isEmpty(board[x][y + 1]) ?  board[x][y + 1].coordinate : currentPosition; 
    }
    case Direction.UP: {
      return !isEmpty(board[x - 1]) && !isEmpty(board[x - 1][y])
        ? board[x - 1][y].coordinate
        : currentPosition;
    }
    case Direction.DOWN: {
      return !isEmpty(board[x + 1]) && !isEmpty(board[x + 1][y])
        ? board[x + 1][y].coordinate
        : currentPosition;
    }
    default:
      return currentPosition;
  }
};

export const nextLeftAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate
): Coordinate => {
  const { x: currentX, y: currentY } = currentPosition;
  const row = board[currentX];

  for (let index = currentY - 1; index > -1; index--) {
    const element = row[index];
    if (element.autogenerated || element.solution === element.value) {
      continue;
    }
    return element.coordinate;
  }
  return currentPosition;
};

export const nextRightAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate
): Coordinate => {
  const { x: currentX, y: currentY } = currentPosition;
  const row = board[currentX];

  for (let index = currentY + 1; index < row.length; index++) {
    const element = row[index];
    if (element.autogenerated || element.solution === element.value) {
      continue;
    }
    return element.coordinate;
  }
  return currentPosition;
};

export const nextDownAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate
): Coordinate => {
  const { x: currentX, y: currentY } = currentPosition;
  const column = getColumn(board, currentY);

  for (let index = currentX + 1; index < column.length; index++) {
    const element = column[index];
    if (element.autogenerated || element.solution === element.value) {
      continue;
    }
    return element.coordinate;
  }
  return currentPosition;
};

export const nextUpAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate
): Coordinate => {
  const { x: currentX, y: currentY } = currentPosition;
  const column = getColumn(board, currentY);

  for (let index = currentX - 1; index > -1; index--) {
    const element = column[index];
    if (element.autogenerated || element.solution === element.value) {
      continue;
    }
    return element.coordinate;
  }
  return currentPosition;
};

export const navigateBoardNextAvailable = (
  board: Cell[][],
  currentPosition: Coordinate,
  direction: string,
): Coordinate => {
  const { x, y } = currentPosition;
  if (isEmpty(board[x][y])) {
    return { x: 0, y: 0 };
  }
  switch (direction) {
    case Direction.LEFT: {
      return nextLeftAvailable(board, currentPosition)
    }
    case Direction.RIGHT: {
      return nextRightAvailable(board, currentPosition)
    }
    case Direction.UP: {
      return nextUpAvailable(board, currentPosition)
    }
    case Direction.DOWN: {
      return nextDownAvailable(board, currentPosition)
    }
    default:
      return currentPosition;
  }
};

// cell is available when is has not been autogenerated or correctly filled
const cellIsAvailable = (cell: Cell) => !(cell.autogenerated || cell.value && cell.solution === cell.value)

const findUpCell = (coordinate: Coordinate) => (item: Coordinable) =>
  item.coordinate.y < coordinate.y;
const findDownCell = (coordinate: Coordinate) => (item: Coordinable) =>
  item.coordinate.y > coordinate.y;
const findLeftCell = (coordinate: Coordinate) => (item: Coordinable) =>
  item.coordinate.x < coordinate.x;
const findRightCell = (coordinate: Coordinate) => (item: Coordinable) =>
  item.coordinate.x > coordinate.x;

export const filterOutByCoordinateNotEqual = (coordinate: Coordinate) => (
  item: Coordinable
) =>
  [item.coordinate.x, item.coordinate.y].join() !==
  [coordinate.x, coordinate.y].join();

const chooseNextBoardCoordinate = (
  coordinate: Coordinate,
  direction: Direction
): Coordinate => {
  const { x, y } = coordinate;
  switch (direction) {
    // loop back to the last column if we reach the first column
    case Direction.UP: {
      return y === 0 ? { x: 8, y: 8 } : { x: 8, y: y - 1 };
    }
    // loop back to the first column if we reach the last column
    case Direction.DOWN: {
      return y === 8 ? { x: 0, y: 0 } : { x: 0, y: y + 1 };
    }
    // loop back to the last row if we reach the first row
    case Direction.LEFT: {
      return x === 0 ? { x: 8, y: 8 } : { x: x - 1, y: 8 };
    }
    // loop back to the first row if we reach the last row
    case Direction.RIGHT: {
      return x === 8 ? { x: 0, y: 0 } : { x: x + 1, y: 0 };
    }
    default:
      return coordinate;
  }
};

const getArea = (board: Cell[][], coordinate: Coordinate, direction: Direction): Cell[] | undefined => {
  switch (direction) {
    case Direction.UP || Direction.DOWN: return getColumn(board, coordinate) 
    case Direction.LEFT || Direction.RIGHT: return getRow(board, coordinate) 
  }
}

export const nextOverflowAvailable = (
  board: Cell[][],
  currentPosition: Coordinate,
  direction: Direction,
): Coordinate => {
  console.error("@position is ", currentPosition);
  // look in the same row or column and see if there is something scanning from the opposite side
  switch (direction) {
    case Direction.UP:
      {
        //getArea(board: Cell[][], currentPosition: Coordinate, direction: Direction): Cell[]
        const column = getColumn(board, currentPosition);
        const filterOutByCoordinateWithCurrentPosition = curry(filterOutByCoordinateNotEqual)(currentPosition)
        const availableCells = column.filter(cellIsAvailable).filter(filterOutByCoordinateWithCurrentPosition);
        // console.error("@available cells", availableCells);
        // try to move upwards in the column
        if (availableCells.length) {
          // getAreaScanHelper(direction: Direction): (coordinate: Coordinate) => Cell
          const findHigherCellWithCurrentPosition = curry(findUpCell)(currentPosition)
          // const nextAvailableCell
          const higherCell = availableCells.find(
            findHigherCellWithCurrentPosition
          );
          if (higherCell) {
            return higherCell.coordinate;
          }
          // try to get lowest possible cell in the column next if any available
          // getOppositeNextAvailableCellHelper(direction: Direction): (Cell[]) => Cell
          const lastItem = last(availableCells)
          if (lastItem) {
            return lastItem.coordinate
          }
        }
        // recurse
        // console.error('@recursing', chooseNextBoardCoordinate(currentPosition, direction))
        return nextOverflowAvailable(board, chooseNextBoardCoordinate(currentPosition, direction), direction)
      }
    default: {
      console.error('@nextOverflowAvailable doing default', )
      return currentPosition
    }
  }
};
