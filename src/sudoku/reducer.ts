import { shuffle, isEqual, isEmpty, cloneDeep, differenceWith, curryRight } from 'lodash'
import { pipe } from 'lodash/fp'
import React, { useReducer, useContext, ReactNode } from 'react';
import { MoveTypes, Move, Cell, ALLOWED_MISTAKES, BOARD_SIZE, GameLevel, Coordinate, NumberDifficulty, VALID_NUMBERS } from './definitions';
import { generateBoard, createGame, difficulty, createNumberDifficultyMap, countAutoGeneratedCells, getConflicts, getRedundantCandidates, getRelatedCells, getRelatedCellsCoordinates } from './utils'
import { getCell, filterByCoordinate } from './board'

export interface State {
  gameLevel?: GameLevel
  mistakes: number
  timeEllapsed?: string
  moves?: Move[] 
  editMode: MoveTypes
  selectedCell: Coordinate
  game: Cell[][]
  cellsToComplete: number
  conflictingCells: Coordinate[]
  selectedCellRelatedCells: Coordinate[]
}

interface Action {
  type: Actions,
  payload?: any
}

export enum Actions {
  RECORD_MISTAKE,
  PAUSE_GAME,
  SET_EDIT_MODE,
  SELECT_CELL,
  START_GAME,
  ISSUE_NUMBER,
  RESOLVE_CELL,
}

export const initialState: State = {
  mistakes: 0,
  editMode: MoveTypes.NUMBER,
  selectedCell: {x: -1, y: -1}, // outside of the board
  cellsToComplete: BOARD_SIZE,
  conflictingCells: [],
  selectedCellRelatedCells: [],
  game: [[]],
}

export const sudokuReducer = (state: State, action: Action) => {
  switch (action.type) {
    case Actions.RECORD_MISTAKE: {
      console.error('@RECORD_MISTAKE', state.mistakes)
      if (state.mistakes === ALLOWED_MISTAKES) {
        console.error('@reducer RECORD_MISTAKE SHOW NEW GAME ALERT', )
      }
      return { ...state, mistakes: state.mistakes + 1 };
    }
    case Actions.START_GAME: {
      const gameLevel: GameLevel = action.payload
      console.error('@START_GAME', gameLevel)
      const board = generateBoard()
      const numberDifficultyMap: NumberDifficulty = createNumberDifficultyMap(difficulty[gameLevel], shuffle(VALID_NUMBERS))
      const autoGeneratedCells = countAutoGeneratedCells(numberDifficultyMap)
      return {
        ...state,
        gameLevel,
        game: createGame(board, numberDifficultyMap),
        cellsToComplete: BOARD_SIZE - autoGeneratedCells
      };
    }
    case Actions.SELECT_CELL: {   
      console.error('@SELECT_CELL', action.payload)
      if (isEqual(state.selectedCell, action.payload)) {
        return state;
      }
      return pipe(
        curryRight(clearConflictingCellsState)(action),
        curryRight(setNewSelectedCell)(action),
        curryRight(manageSelectedCellRelatedCells)(action),
      )(state)
    }
    case Actions.SET_EDIT_MODE: {
      console.error('@SET_EDIT_MODE', action.payload)
      const editMode: MoveTypes = action.payload
      return { ...state, editMode }
    }
    case Actions.ISSUE_NUMBER: {
      return state.editMode === MoveTypes.NUMBER
        ? setCellValue(state, action.payload)
        : setCellCandidate(state, action.payload);
    }
    case Actions.RESOLVE_CELL: {
      console.error('@RESOLVE CELL', process.env.REACT_APP_DEV_MODE, action.payload)
      if (!process.env.REACT_APP_DEV_MODE) {
        return 
      }
      const game = state.game
      let cellsToComplete = state.cellsToComplete
      //@ts-ignore
      const {x, y} = state.selectedCell  
      const cell = game[x][y]
      if (cell.value !== cell.solution) {
        cellsToComplete--
      }
      cell.value = cell.solution 
      return { ...state, game, cellsToComplete}
    }
    default: throw new Error(`Unexpected Sudoku reducer action ${action.type}`);
  }
};

export const setCellValue = (state: State, number: number) => {
  console.error('@ISSUE_NUMBER', number)
  let { game, selectedCell } = state
  let cellsToComplete = state.cellsToComplete
  const { x, y } = selectedCell
  const cell = game[x][y]
  cell.value = number;
  if (number === cell.solution) {
    cellsToComplete--
    game = removeConflictingCandidates(game, cell)
  }
  return { ...state, game, cellsToComplete }
}

export const removeConflictingCandidates = (board: Cell[][], cell: Cell): Cell[][] => {
  let b = cloneDeep(board)
  const redundantCandidates = getRedundantCandidates(cell, b)
  redundantCandidates && redundantCandidates.forEach((c: Coordinate) => {
    const boardCell = b[c.x][c.y]
    boardCell && boardCell.candidates && delete boardCell.candidates[cell.solution]
  }); 
  return b
}

export const manageSelectedCellRelatedCells = (state: State, action: Action): State => {
  const newSelectedCell: Coordinate = action.payload
  const { game, selectedCellRelatedCells } = state
  const newRelatedCells = getRelatedCellsCoordinates(newSelectedCell, game);
  console.error("@nrc", newRelatedCells);
  setRelatedCells(game, newRelatedCells, selectedCellRelatedCells || []);
  removeUnrelatedCells(game, newRelatedCells, selectedCellRelatedCells);
  return {...state, game, selectedCellRelatedCells: newRelatedCells };
}

export const setRelatedCells = (
  board: Cell[][],
  newRelatedCells: Coordinate[],
  existingRelatedCells: Coordinate[]
): Cell[][] => {
  let b = board;
  // let b = cloneDeep(board);
  if (!existingRelatedCells.length) {
    newRelatedCells.forEach((c: Coordinate) => {
      b[c.x][c.y].related = true  
    })
  } else {
    // do difference between new and existing
    const differentCells = differenceWith(
      newRelatedCells,
      existingRelatedCells,
      isEqual
    );
    differentCells.forEach((c: Coordinate) => b[c.x][c.y].related = true); 
  }
  return b
};

export const removeUnrelatedCells = (
  board: Cell[][],
  newRelatedCells: Coordinate[],
  existingRelatedCells: Coordinate[]
): Cell[][] => {
  // let b = cloneDeep(board);
  let b = board;
  const differentCells = differenceWith(
    existingRelatedCells,
    newRelatedCells,
    isEqual
  );
  differentCells.forEach((c: Coordinate) => delete b[c.x][c.y].related);
  return b;
};

// @TODO: remove impurity
export const setCellCandidate = (state: State, number: number) => {
  console.error('@SET_CELL_CANDIDATE', number)
  const { game, selectedCell, conflictingCells } = state
  if (!selectedCell || getCell(selectedCell, game).value) {
    return state
  }
  clearConflictingCells(game, conflictingCells)
  let candidateConflicts: Coordinate[] = getCandidateConflictingCells(number, selectedCell, game)
  if (isEmpty(candidateConflicts)) {  
    setCandidate(game, selectedCell, number)
  }
  return { ...state, game, conflictingCells: candidateConflicts }
}

// @TODO: remove impurity
export const clearConflictingCells = (
  game: Cell[][],
  conflictingCells: Coordinate[]
) =>
  conflictingCells &&
  conflictingCells.forEach((c: Coordinate) => {
    delete game[c.x][c.y].conflicting;
  });

export const clearConflictingCellsState = (state: State, action: Action): State => {
  console.error('@clearConflictingCellsState', action, state)
  const { game, conflictingCells } = state
  clearConflictingCells(game, conflictingCells)
  return { ...state, game }
}

export const setNewSelectedCell = (state: State, action: Action): State => {
  console.error('@setNewSelectedCell', action, state)
  const { selectedCell, game } = state
  const newSelectedCell: Coordinate = action.payload
  const { x: newX, y: newY } = newSelectedCell;
  if (selectedCell) {
    const { x: currentX, y: currentY } = selectedCell;
    delete game[currentX][currentY].selected
  }
  game[newX][newY].selected = true
  return { ...state, game, selectedCell:newSelectedCell }
}

// @TODO: remove impurity
export const getCandidateConflictingCells = (candidate: number, coordinate: Coordinate, game: Cell[][]): Coordinate[] => {
  const candidateConflicts = getConflicts(candidate, coordinate, game)
  if (candidateConflicts.length) {
    candidateConflicts.forEach((c: Coordinate) => {
      game[c.x][c.y].conflicting = true 
    })
  }
  return candidateConflicts
}

// @TODO: remove impurity
export const setCandidate = (game: Cell[][], coordinate: Coordinate, number: number) => {
  const cell = getCell(coordinate, game)
  if (!cell) {
    return
  }
  if (!cell.candidates) {
    cell.candidates = {};
  }
  if (cell.candidates && !cell.candidates[number]) {
    cell.candidates[number] = { entered: true, selected: false};
  } else if (cell.candidates && cell.candidates[number]) {
    cell.candidates[number].entered = !cell.candidates[number].entered;
  }
}

// const SudokuContext = React.createContext(initialState);

// interface ProviderProps {
//   children: ReactNode
// }

// export const SudokuProvider = ({ children }: ProviderProps): JSX.Element => {
//   const contextValue = useReducer(sudokuReducer, initialState);
//   return (
//     //@ts-ignore
//     <SudokuContext.Provider value={contextValue}>
//       {children}
//     </SudokuContext.Provider>
//   );
// };

// export const useSudoku = () => useContext(SudokuContext)
