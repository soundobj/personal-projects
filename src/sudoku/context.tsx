import { shuffle, isEqual } from 'lodash'
import React, { useReducer, useContext, ReactNode } from 'react';
import { MoveTypes, Move, Cell, ALLOWED_MISTAKES, BOARD_SIZE, GameLevel, Coordinate, NumberDifficulty, VALID_NUMBERS } from './definitions';
import { generateBoard, createGame, difficulty, createNumberDifficultyMap, countAutoGeneratedCells } from './utils'

interface State {
  gameLevel?: GameLevel
  mistakes: number
  timeEllapsed?: string
  moves?: Move[] 
  editMode: MoveTypes
  selectedCell?: Coordinate
  game?: Cell[][]
  cellsToComplete: number
}

interface Action {
  type: Actions,
  payload?: any
}

export enum Actions {
  RECORD_MISTAKE,
  PAUSE_GAME,
  SET_EDIT_MODE,
  SELECT_CELL,
  START_GAME,
  ISSUE_NUMBER,
  RESOLVE_CELL,
}

export const initialState: State = {
  mistakes: 0,
  editMode: MoveTypes.NUMBER,
  selectedCell: undefined,
  cellsToComplete: BOARD_SIZE
}

export const sudokuReducer = (state: State, action: Action ) => {
  switch (action.type) {
    case Actions.RECORD_MISTAKE: {
      console.error('@RECORD_MISTAKE', state.mistakes)
      if (state.mistakes === ALLOWED_MISTAKES) {
        console.error('@reducer RECORD_MISTAKE SHOW NEW GAME ALERT', )
      }
      return { ...state, mistakes: state.mistakes + 1 };
    }
    case Actions.START_GAME: {
      const gameLevel: GameLevel = action.payload
      console.error('@START_GAME', gameLevel)
      const board = generateBoard()
      const numberDifficultyMap: NumberDifficulty = createNumberDifficultyMap(difficulty[gameLevel], shuffle(VALID_NUMBERS))
      const autoGeneratedCells = countAutoGeneratedCells(numberDifficultyMap)
      return {
        ...state,
        gameLevel: action.payload,
        game: createGame(board, numberDifficultyMap),
        cellsToComplete: BOARD_SIZE - autoGeneratedCells
      };
    }
    case Actions.SELECT_CELL: {
      console.error('@SELECT_CELL', action.payload)
      const currentSelectedCell = state.selectedCell
      const selectedCell: Coordinate = action.payload
      if (isEqual(currentSelectedCell, selectedCell)) {
        return state;
      }
      const { x: newX, y: newY } = selectedCell;
      const game = state.game
      if (game) {
        if (currentSelectedCell) {
          const { x: currentX, y: currentY } = currentSelectedCell;
          delete game[currentX][currentY].selected
        }
        game[newX][newY].selected = true
      }
      return { ...state, selectedCell, game }
    }
    case Actions.SET_EDIT_MODE: {
      console.error('@SET_EDIT_MODE', action.payload)
      const editMode: MoveTypes = action.payload
      return { ...state, editMode }
    }
    case Actions.ISSUE_NUMBER: {
      console.error('@ISSUE_NUMBER', action.payload)
      const { game, selectedCell } = state
      if (!selectedCell) {
        return state
      }
      const { x, y } = selectedCell
      if (game) {
        game[x][y].value = action.payload;
      }
      return { ...state, game }
    }
    case Actions.RESOLVE_CELL: {
      console.error('@RESOLVE CELL', process.env.REACT_APP_DEV_MODE, action.payload)
      if (!process.env.REACT_APP_DEV_MODE) {
        return 
      }
      const coordinate: Coordinate = action.payload
      const game = state.game
      //@ts-ignore
      const {x, y} = state.selectedCell
      if (game) {
        game[x][y].value = game[x][y].solution
      }
      return { ...state, game}
    }
    default: throw new Error(`Unexpected Sudoku reducer action ${action.type}`);
  }
};

// const SudokuContext = React.createContext(initialState);

// interface ProviderProps {
//   children: ReactNode
// }

// export const SudokuProvider = ({ children }: ProviderProps): JSX.Element => {
//   const contextValue = useReducer(sudokuReducer, initialState);
//   return (
//     //@ts-ignore
//     <SudokuContext.Provider value={contextValue}>
//       {children}
//     </SudokuContext.Provider>
//   );
// };

// export const useSudoku = () => useContext(SudokuContext)
