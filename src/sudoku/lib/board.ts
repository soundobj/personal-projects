import { isEmpty, isEqual, curryRight } from "lodash";
import { Cell, Coordinate, Coordinable, Direction } from "./definitions";
import { getRow, getColumn } from './utils'

export const isValidMoveType = (value: string): value is keyof typeof Direction => {
  return value in Direction;
}

/*
  navigates the board one cell at a time stopping at edges of the board
*/
export const navigateBoard = (
  board: Coordinable[][],
  currentPosition: Coordinate,
  direction: string
): Coordinate => {
  const { x, y } = currentPosition;
  if (isEmpty(board[x][y])) {
    return { x: 0, y: 0 };
  }
  switch (direction) {
    case Direction.LEFT: {
      return !isEmpty(board[x][y - 1]) ?  board[x][y - 1].coordinate : currentPosition; 
    }
    case Direction.RIGHT: {
      return !isEmpty(board[x][y + 1]) ?  board[x][y + 1].coordinate : currentPosition; 
    }
    case Direction.UP: {
      return !isEmpty(board[x - 1]) && !isEmpty(board[x - 1][y])
        ? board[x - 1][y].coordinate
        : currentPosition;
    }
    case Direction.DOWN: {
      return !isEmpty(board[x + 1]) && !isEmpty(board[x + 1][y])
        ? board[x + 1][y].coordinate
        : currentPosition;
    }
    default:
      return currentPosition;
  }
};

export const findNextByCriteria = <T extends Cell>(
  list: T[],
  startCoordinate: Coordinate,
  includeStartIndex: boolean = false,
  criteriaHandler: (element: T) => boolean
): Coordinate | undefined => {
  const coordinateIndex = list.findIndex(curryRight(filterByCellCoordinate)(startCoordinate))
  const start = includeStartIndex ? coordinateIndex : coordinateIndex + 1
  for (let index = start; index < list.length; index++) {
    const element = list[index];
    if (criteriaHandler(element)) {
      return element.coordinate;
    }
  }
  return startCoordinate;
}

// cell is available when is has not been autogenerated or correctly filled
export const cellIsAvailable = (cell: Cell) => !(cell.autogenerated || cell.value && cell.solution === cell.value)

const findNextSudokuAvailableCell = curryRight(findNextByCriteria)(cellIsAvailable)

export const nextLeftAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate,
  includeStartIndex: boolean = false
): Coordinate => {
  const list = getRow(board, currentPosition).reverse()
  return findNextSudokuAvailableCell(list, currentPosition, includeStartIndex)
};

export const nextRightAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate,
  includeStartIndex: boolean = false
): Coordinate => {
  const list = getRow(board, currentPosition)
  return findNextSudokuAvailableCell(list, currentPosition, includeStartIndex)
};

export const nextDownAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate,
  includeStartIndex: boolean = false
): Coordinate => {
  const list = getColumn(board, currentPosition)
  return findNextSudokuAvailableCell(list, currentPosition, includeStartIndex)
};

export const nextUpAvailable = <T extends Cell>(
  board: T[][],
  currentPosition: Coordinate,
  includeStartIndex: boolean = false
): Coordinate => {
  const list = getColumn(board, currentPosition).reverse()
  return findNextSudokuAvailableCell(list, currentPosition, includeStartIndex)
};

/*
  navigates the board, skipping any correct cells, stopping at the edges of the board
*/
export const navigateBoardNextAvailable = (
  board: Cell[][],
  currentPosition: Coordinate,
  direction: string,
): Coordinate => {
  const { x, y } = currentPosition; 
  if (isEmpty(board[x][y])) {
    return { x: 0, y: 0 };
  }
  switch (direction) {
    case Direction.LEFT: {
      return nextLeftAvailable(board, currentPosition)
    }
    case Direction.RIGHT: {
      return nextRightAvailable(board, currentPosition)
    }
    case Direction.UP: {
      return nextUpAvailable(board, currentPosition)
    }
    case Direction.DOWN: {
      return nextDownAvailable(board, currentPosition)
    }
    default:
      return currentPosition;
  }
};

export const filterOutCoordinate = (coordinate: Coordinate) => (
  item: Coordinate
) =>
  [coordinate.x, coordinate.y].join() !== [item.x, item.y].join();

export const filterByCoordinate = (coordinate: Coordinate) => (
  item: Coordinate
) =>
  [coordinate.x, coordinate.y].join() === [item.x, item.y].join();

export const filterOutCellByCoordinate = (coordinate: Coordinate) => (
  item: Coordinable
) => [coordinate.x, coordinate.y].join() !== [item.coordinate.x, item.coordinate.y].join();

export const filterByCellCoordinate = (coordinate: Coordinate) => (
  item: Coordinable
) => [coordinate.x, coordinate.y].join() === [item.coordinate.x, item.coordinate.y].join();

export const getBoardDimensions = (board: Cell[][]): Coordinate => {
  const coordinate: Coordinate = { x: 0, y: 0 }
  if (board.length) {
    coordinate.x = board.length
  }
  if (board[0]) {
    coordinate.y = board[0].length
  }
  return coordinate
}

/* 
  returns the next row or column coordinate in a LEFT DOWN clockwise direction and RIGHT UP anti clockwise direction 
  it wraps around if at the edges of the board creating a wrapping loop
*/
export const getNextAreaCoordinate = (c: Coordinate, direction: Direction): Coordinate => {
  switch (direction) {
    case Direction.UP: return c.y === 0 ? { x: 8, y: 8 } : { x: 9, y: c.y - 1 }
    case Direction.DOWN: return c.y === 8 ? { x: 0, y: 0 } : { x: -1, y: c.y + 1 }
    case Direction.LEFT: return c.x === 0 ? { x: 8, y: 8 } : { x: c.x - 1, y: 9 }
    case Direction.RIGHT: return c.x === 8 ? { x: 0, y: 0 } : { x: c.x + 1, y: -1 }
  }
}
 
export const getCell = (coordinate: Coordinate, board: Cell[][]): Cell => {
  const {x, y} = coordinate
  return board[x][y]
}

export const getOppositeCoordinateInList = (currentPosition: Coordinate, direction: Direction): Coordinate => {
  const {x, y} = currentPosition
  switch (direction) {
    case Direction.UP: return ({x: 8, y})
    case Direction.DOWN: return ({x: 0, y})
    case Direction.LEFT: return ({x, y: 8})
    case Direction.RIGHT: return ({x, y: 0})
  }
}

type NextPositionDirectionHandler = (board: Cell[][], coordinate: Coordinate, includeStartIndex?: boolean) => Coordinate

export const getNextPositionDirectionHandler = (direction: Direction): NextPositionDirectionHandler => {
  switch (direction) {
    case Direction.UP: return nextUpAvailable
    case Direction.DOWN: return nextDownAvailable
    case Direction.LEFT: return nextLeftAvailable
    case Direction.RIGHT: return nextRightAvailable
  }
}

export const nextOverFlowAvailable = (
  board: Cell[][],
  currentPosition: Coordinate,
  direction: Direction 
): Coordinate | undefined => {
  const nextHandler = getNextPositionDirectionHandler(direction)
  const nextUp = nextHandler(board, currentPosition)
  if (!isEqual(nextUp, currentPosition) && cellIsAvailable(getCell(nextUp, board))) {
    return nextUp
  }
  const oppositeCoordinateInList = getOppositeCoordinateInList(currentPosition, direction)
  const nextUpFromOpposite = nextHandler(board, oppositeCoordinateInList, true)
  if (!isEqual(nextUpFromOpposite, currentPosition) && cellIsAvailable(getCell(nextUpFromOpposite, board))) {
    return nextUpFromOpposite
  }
};

/*
  Overflow navigation features:
  - selecting the opposite end of the row / column when the user uses the keyboard navigation control in the direction where there are not available cells to move
  - selecting the next row / column with available cells when the user uses the keyboard navigation control in the direction where there are not available cells to move and there is a single available cell in the column / row which is the one currently selected
*/
export const navigateBoardNextAvailableOverflow = (
  board: Cell[][],
  currentPosition: Coordinate,
  direction: Direction,
  cellsToComplete?: number
): Coordinate => {
  if (cellsToComplete && cellsToComplete > 0) {
    return (
      nextOverFlowAvailable(board, currentPosition, direction) ||
      navigateBoardNextAvailableOverflow(
        board,
        getNextAreaCoordinate(currentPosition, direction),
        direction,
        cellsToComplete
      )
    );
  }
  return currentPosition;
};
