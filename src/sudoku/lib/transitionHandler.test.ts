// @ts-nocheck
import { compact } from 'lodash'
import transitionHandler, { mapRandomClassToVisibleCellsInBoard } from "./transitionHandler";
import { Cell } from './definitions'
describe("transitionHandler", () => {
  const elements = {}; // element instances to trigger events
  const map = {}; // element event map of callbacks
  const addEventListenerMock = jest.fn((event, cb) => {
    map[event] = cb;
  });
  const removeEventListenerMock = jest.fn();

  global.document = {
    querySelector: jest.fn((selector) => {
      const element = {};
      element.addEventListener = addEventListenerMock;
      element.removeEventListener = removeEventListenerMock;
      elements[selector] = {
        map,
      };
      return element;
    }),
  };

  it("listens for all transition events and executes a callback when all resolved", (done) => {
    const event = "animationend";
    const selector = "#foo";
    
    // event name must be unique for mocking purposes
    const event1 = "transitionend";
    const selector1 = "#bar";

    const transitions = [
      {
        event,
        selector,
      },
      {
        event:event1,
        selector:selector1,
      },
    ];

    transitionHandler(transitions).then(() => {
      expect(addEventListenerMock).toHaveBeenCalledTimes(2)
      expect(removeEventListenerMock).toHaveBeenCalledTimes(2)
      done();
    });

    // trigger events to resolve promises
    elements[selector].map[event]();
    elements[selector1].map[event1]();
  });
  describe('randomClassByCriteria', () => {
    it('generates a list of classes to apply to a list and a list of featuring classes on the list', () => {
      const list = [
        {
          solution: 1,
          autogenerated: true,
        },
        {
          solution: 2,
          autogenerated: false,
          value: 2,
        },
        {
          solution: 3,
          autogenerated: false,
        },
      ] as Cell[]

      const items = ['foo', 'bar', 'bazz']
      const res = mapRandomClassToVisibleCellsInBoard(list, items)
      expect(res.list[2]).toEqual(undefined)
      expect(items).toEqual(expect.arrayContaining(res.applied));
      expect(compact(res.list)).toEqual(expect.arrayContaining(res.applied));
    })
  })
});
